# 4. 쿼리 메소드 기능

스프링 데이터 JPA가 제공하는 마법 같은 기능입니다.

## 쿼리 메소드 기능 3가지
1.  **메소드 이름으로 쿼리 생성**: 메소드 이름을 분석해서 JPQL 쿼리를 실행합니다.
2.  **메소드 이름으로 JPA NamedQuery 호출**: `@NamedQuery` 어노테이션으로 정의된 Named 쿼리를 호출합니다.
3.  **`@Query` 어노테이션을 사용해서 리파지토리 인터페이스에 쿼리 직접 정의**: 인터페이스 메소드에 JPQL 쿼리를 직접 작성합니다.

## 메소드 이름으로 쿼리 생성
*   스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행합니다.
*   **쿼리 메소드 필터 조건**: 스프링 데이터 JPA 공식 문서 (https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)를 참고하면 다양한 쿼리 메소드 기능을 확인할 수 있습니다.
    *   `find...By`, `read...By`, `query...By`, `get...By`
    *   `COUNT`: `count...By` 반환타입 `long`
    *   `EXISTS`: `exists...By` 반환타입 `boolean`
    *   `삭제`: `delete...By`, `remove...By` 반환타입 `long`
    *   `DISTINCT`: `findDistinct`, `findMemberDistinctBy`
    *   `LIMIT`: `findFirst3`, `findFirst`, `findTop`, `findTop3`
*   **주의**: 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야 합니다. 그렇지 않으면 애플리케이션을 시작하는 시점에 오류가 발생합니다. 이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점입니다.

## JPA NamedQuery
*   JPA의 `NamedQuery`를 호출할 수 있습니다.
*   **`@NamedQuery` 어노테이션으로 Named 쿼리 정의**: `@Entity`에 정의할 수 있습니다.
*   **스프링 데이터 JPA로 NamedQuery 사용**: `@Query(name = "NamedQueryName")` 어노테이션을 사용하거나, `@Query`를 생략하고 메서드 이름만으로 Named 쿼리를 호출할 수 있습니다.
*   **주의**: 스프링 데이터 JPA를 사용하면 실무에서 Named Query를 직접 등록해서 사용하는 일은 드뭅니다. 대신 `@Query`를 사용해서 리파지토리 메소드에 쿼리를 직접 정의합니다.

## `@Query`, 리포지토리 메소드에 쿼리 정의하기
*   **메서드에 JPQL 쿼리 작성**: `@Query` 어노테이션에 JPQL 쿼리를 직접 작성합니다.
*   `@org.springframework.data.jpa.repository.Query` 어노테이션을 사용합니다.
*   실행할 메서드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있습니다.
*   JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있습니다 (매우 큰 장점!).
*   **참고**: 실무에서는 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해집니다. 따라서 `@Query` 기능을 자주 사용하게 됩니다.

### `@Query`, 값, DTO 조회하기
*   **단순히 값 하나를 조회**: `List<String> findUsernameList()`와 같이 사용할 수 있습니다.
*   **DTO로 직접 조회**: `select new 패키지명.DTO명(필드1, 필드2...) from ...`과 같이 JPA의 `new` 명령어를 사용해야 합니다. 그리고 생성자가 맞는 DTO가 필요합니다.

## 파라미터 바인딩
*   **위치 기반**: `?0`, `?1` 등 인덱스를 사용하여 파라미터를 바인딩합니다.
*   **이름 기반**: `:paramName`과 같이 이름을 사용하여 파라미터를 바인딩합니다. `@Param("paramName")` 어노테이션을 사용합니다.
*   **참고**: 코드 가독성과 유지보수를 위해 이름 기반 파라미터 바인딩을 사용하는 것이 좋습니다 (위치 기반은 순서가 바뀌면 오류가 발생할 수 있습니다).
*   **컬렉션 파라미터 바인딩**: `Collection` 타입으로 `in` 절을 지원합니다. (`@Query("select m from Member m where m.username in :names")`)

## 반환 타입
*   스프링 데이터 JPA는 유연한 반환 타입을 지원합니다.
*   `List<Member>`, `Member`, `Optional<Member>` 등이 가능합니다.
*   **조회 결과가 많거나 없으면?**
    *   **컬렉션**: 결과가 없으면 빈 컬렉션을 반환합니다.
    *   **단건 조회**: 결과가 없으면 `null`을 반환합니다. 결과가 2건 이상이면 `javax.persistence.NonUniqueResultException` 예외가 발생합니다.
*   **참고**: 단건으로 지정한 메서드를 호출하면 스프링 데이터 JPA는 내부에서 JPQL의 `Query.getSingleResult()` 메서드를 호출합니다. 이 메서드를 호출했을 때 조회 결과가 없으면 `javax.persistence.NoResultException` 예외가 발생하는데 개발자 입장에서 다루기가 상당히 불편합니다. 스프링 데이터 JPA는 단건을 조회할 때 이 예외가 발생하면 예외를 무시하고 대신에 `null`을 반환합니다.

## 순수 JPA 페이징과 정렬
*   JPA에서 페이징과 정렬은 `setFirstResult(offset)`과 `setMaxResults(limit)`를 사용하여 구현합니다.
*   총 카운트 쿼리도 별도로 실행해야 합니다.

## 스프링 데이터 JPA 페이징과 정렬
*   **페이징과 정렬 파라미터**:
    *   `org.springframework.data.domain.Sort`: 정렬 기능
    *   `org.springframework.data.domain.Pageable`: 페이징 기능 (내부에 Sort 포함)
*   **특별한 반환 타입**:
    *   `org.springframework.data.domain.Page<T>`: 추가 count 쿼리 결과를 포함하는 페이징 정보를 반환합니다.
    *   `org.springframework.data.domain.Slice<T>`: 추가 count 쿼리 없이 다음 페이지만 확인 가능합니다 (내부적으로 limit + 1 조회).
    *   `List<T>` (자바 컬렉션): 추가 count 쿼리 없이 결과만 반환합니다.
*   **참고**: `Pageable`은 인터페이스입니다. 따라서 실제 사용할 때는 해당 인터페이스를 구현한 `org.springframework.data.domain.PageRequest` 객체를 사용합니다. `PageRequest` 생성자의 첫 번째 파라미터에는 현재 페이지를, 두 번째 파라미터에는 조회할 데이터 수를 입력합니다. 여기에 추가로 정렬 정보도 파라미터로 사용할 수 있습니다. **참고로 페이지는 0부터 시작합니다.**
*   `Page` 인터페이스와 `Slice` 인터페이스는 페이지 정보와 데이터를 제공합니다.
*   **count 쿼리를 분리**: `@Query(value = "select m from Member m", countQuery = "select count(m.username) from Member m")`와 같이 `value`와 `countQuery`를 분리하여 사용할 수 있습니다.

## 스프링 부트 3 - 하이버네이트 6 left join 최적화 설명 추가
*   스프링 부트 3 이상을 사용하면 하이버네이트 6이 적용됩니다.
*   하이버네이트 6은 의미 없는 `left join`을 최적화하여 제거할 수 있습니다.
*   `left join` 이기 때문에 왼쪽에 있는 엔티티 자체를 다 조회한다는 뜻이 됩니다. 만약 `select`나 `where`에 `team`의 조건이 들어간다면 정상적인 `join` 문이 보입니다. JPA는 이 경우 최적화를 해서 `join` 없이 해당 내용만으로 SQL을 만듭니다.
*   `Member`와 `Team`을 하나의 SQL로 한번에 조회하고 싶다면 JPA가 제공하는 `fetch join`을 사용해야 합니다.

## 벌크성 수정 쿼리
*   **JPA를 사용한 벌크성 수정 쿼리**: `EntityManager.createQuery("update ...").executeUpdate()`를 사용합니다.
*   **스프링 데이터 JPA를 사용한 벌크성 수정 쿼리**: `@Modifying` 어노테이션과 `@Query` 어노테이션을 함께 사용합니다.
    *   `@Modifying` 어노테이션을 사용하지 않으면 `QueryExecutionRequestException` 예외가 발생합니다.
    *   `@Modifying(clearAutomatically = true)`를 사용하여 벌크성 쿼리 실행 후 영속성 컨텍스트를 초기화하는 것이 중요합니다. 이 옵션의 기본값은 `false`입니다.
    *   이 옵션 없이 회원을 `findById`로 다시 조회하면 영속성 컨텍스트에 과거 값이 남아서 문제가 될 수 있습니다. 만약 다시 조회해야 하면 꼭 영속성 컨텍스트를 초기화 해야 합니다.
*   **참고**: 벌크 연산은 영속성 컨텍스트를 무시하고 실행하기 때문에, 영속성 컨텍스트에 있는 엔티티의 상태와 DB에 엔티티 상태가 달라질 수 있습니다.
    *   **권장하는 방안**:
        1.  영속성 컨텍스트에 엔티티가 없는 상태에서 벌크 연산을 먼저 실행합니다.
        2.  부득이하게 영속성 컨텍스트에 엔티티가 있으면 벌크 연산 직후 영속성 컨텍스트를 초기화 합니다.

## `@EntityGraph`
*   연관된 엔티티들을 SQL 한번에 조회하는 방법입니다.
*   `member -> team`은 지연로딩 관계이므로, `team`의 데이터를 조회할 때마다 쿼리가 실행됩니다 (N+1 문제 발생).
*   페치 조인이 필요합니다.
*   **JPQL 페치 조인**: `@Query("select m from Member m left join fetch m.team")`
*   스프링 데이터 JPA는 JPA가 제공하는 엔티티 그래프 기능을 편리하게 사용하게 도와줍니다. 이 기능을 사용하면 JPQL 없이 페치 조인을 사용할 수 있습니다 (JPQL + 엔티티 그래프도 가능).
*   **EntityGraph 정리**:
    *   사실상 페치 조인(FETCH JOIN)의 간편 버전입니다.
    *   LEFT OUTER JOIN을 사용합니다.
    *   **NamedEntityGraph 사용 방법**: `@NamedEntityGraph`와 `@NamedAttributeNode` 어노테이션을 사용하여 정의합니다. `@EntityGraph("NamedEntityGraphName")` 어노테이션을 사용하여 NamedEntityGraph를 적용할 수 있습니다.

## JPA Hint & Lock
### JPA Hint
*   JPA 쿼리 힌트(SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트)
*   **쿼리 힌트 사용**: `@QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))` 어노테이션을 사용하여 쿼리 힌트를 적용할 수 있습니다.
*   `forCounting`: 반환 타입으로 `Page` 인터페이스를 적용하면 추가로 호출하는 페이징을 위한 count 쿼리에도 쿼리 힌트 적용 (기본값 `true`).

### Lock
*   `@Lock(LockModeType.PESSIMISTIC_WRITE)` 어노테이션을 사용하여 Lock을 적용할 수 있습니다.
*   `org.springframework.data.jpa.repository.Lock` 어노테이션을 사용합니다.
*   JPA가 제공하는 락에 대한 자세한 내용은 JPA 책의 16.1 트랜잭션과 락 절을 참고합니다.
