# 7. 나머지 기능들

## Specifications (명세)
*   도메인 주도 설계(Domain Driven Design)는 SPECIFICATION(명세)이라는 개념을 소개합니다.
*   스프링 데이터 JPA는 JPA Criteria를 활용해서 이 개념을 사용할 수 있도록 지원합니다.

### 술어(predicate)
*   참 또는 거짓으로 평가됩니다.
*   AND OR 같은 연산자로 조합해서 다양한 검색조건을 쉽게 생성할 수 있습니다 (컴포지트 패턴).
*   스프링 데이터 JPA는 `org.springframework.data.jpa.domain.Specification` 클래스로 정의됩니다.

### 명세 기능 사용 방법
*   `JpaSpecificationExecutor` 인터페이스를 상속받습니다.
*   `JpaSpecificationExecutor` 인터페이스는 `findOne`, `findAll`, `count` 등의 메서드를 제공하며, `Specification<T>`를 파라미터로 받아서 검색 조건으로 사용합니다.
*   **Specification 구현**: 명세를 정의하려면 `Specification` 인터페이스를 구현해야 합니다. `toPredicate(...)` 메서드만 구현하면 되며, JPA Criteria의 `Root`, `CriteriaQuery`, `CriteriaBuilder` 클래스를 파라미터로 제공합니다.
*   **참고**: 실무에서는 JPA Criteria를 거의 사용하지 않고, 대신 QueryDSL을 사용합니다.

## Query By Example
*   엔티티를 프로브(Probe)로 사용하여 동적 쿼리를 편리하게 처리하는 방법입니다.
*   **Probe**: 필드에 데이터가 있는 실제 도메인 객체입니다.
*   **ExampleMatcher**: 특정 필드를 일치시키는 상세한 정보 제공 및 재사용이 가능합니다.
*   **Example**: Probe와 ExampleMatcher로 구성되며, 쿼리를 생성하는 데 사용됩니다.

### 장점
*   동적 쿼리를 편리하게 처리할 수 있습니다.
*   도메인 객체를 그대로 사용합니다.
*   데이터 저장소를 RDB에서 NOSQL로 변경해도 코드 변경이 없게 추상화되어 있습니다.
*   스프링 데이터 JPA `JpaRepository` 인터페이스에 이미 포함되어 있습니다.

### 단점
*   조인은 가능하지만 내부 조인(INNER JOIN)만 가능하며 외부 조인(LEFT JOIN)은 지원하지 않습니다.
*   중첩된 제약 조건은 지원하지 않습니다. (예: `firstname = ?0 or (firstname = ?1 and lastname = ?2)`)
*   매칭 조건이 매우 단순합니다.
    *   문자는 `starts/contains/ends/regex`만 지원합니다.
    *   다른 속성은 정확한 매칭 (`=`)만 지원합니다.
*   **정리**: 실무에서 사용하기에는 매칭 조건이 너무 단순하고, LEFT 조인이 안 됩니다. 실무에서는 단순할 때만 사용하고, 조금만 복잡해지면 QueryDSL을 사용합니다.

## Projections
*   엔티티 대신에 DTO를 편리하게 조회할 때 사용합니다.
*   전체 엔티티가 아니라 만약 회원 이름만 딱 조회하고 싶을 때 유용합니다.

### 인터페이스 기반 Closed Projections
*   프로퍼티 형식(getter)의 인터페이스를 제공하면, 구현체는 스프링 데이터 JPA가 제공합니다.
*   조회할 엔티티의 필드를 getter 형식으로 지정하면 해당 필드만 선택해서 조회합니다 (Projection).
*   메서드 이름은 자유롭고, 반환 타입으로 인지합니다.

### 인터페이스 기반 Open Projections
*   스프링의 SpEL 문법도 지원합니다. (예: `@Value("#{target.username + ' ' + target.age}")`)
*   **단! 이렇게 SpEL 문법을 사용하면, DB에서 엔티티 필드를 다 조회해온 다음에 계산하므로 JPQL SELECT 절 최적화가 안 됩니다.**

### 클래스 기반 Projection
*   인터페이스가 아닌 구체적인 DTO 형식도 가능합니다.
*   생성자의 파라미터 이름으로 매칭됩니다.

### 동적 Projections
*   Generic type을 주면, 동적으로 프로젝션 데이터 변경이 가능합니다. (예: `<T> List<T> findProjectionsByUsername(String username, Class<T> type);`)

### 중첩 구조 처리
*   인터페이스 안에 인터페이스를 정의하여 중첩된 구조를 처리할 수 있습니다.

### 주의
*   프로젝션 대상이 root 엔티티면, JPQL SELECT 절 최적화가 가능합니다.
*   프로젝션 대상이 ROOT가 아니면 LEFT OUTER JOIN 처리되며, 모든 필드를 SELECT해서 엔티티로 조회한 다음에 계산합니다.
*   **정리**:
    *   프로젝션 대상이 root 엔티티면 유용합니다.
    *   프로젝션 대상이 root 엔티티를 넘어가면 JPQL SELECT 최적화가 안 됩니다!
    *   실무의 복잡한 쿼리를 해결하기에는 한계가 있습니다.
    *   실무에서는 단순할 때만 사용하고, 조금만 복잡해지면 QueryDSL을 사용합니다.

## 네이티브 쿼리
*   가급적 네이티브 쿼리는 사용하지 않는 것이 좋으며, 정말 어쩔 수 없을 때 사용합니다.
*   최근에 나온 궁극의 방법은 스프링 데이터 Projections를 활용하는 것입니다.

### 스프링 데이터 JPA 기반 네이티브 쿼리
*   **`@Query(value = "SELECT * FROM member WHERE username = ?", nativeQuery = true)`** 어노테이션을 사용합니다.
*   **페이징 지원**
*   **반환 타입**: `Object[]`, `Tuple`, DTO (스프링 데이터 인터페이스 Projections 지원)
*   **제약**:
    *   `Sort` 파라미터를 통한 정렬이 정상 동작하지 않을 수 있습니다 (믿지 말고 직접 처리).
    *   JPQL처럼 애플리케이션 로딩 시점에 문법 확인 불가합니다.
    *   동적 쿼리 불가합니다.
*   **참고**: JPQL은 위치 기반 파라미터를 1부터 시작하지만 네이티브 SQL은 0부터 시작합니다.
*   **네이티브 SQL을 엔티티가 아닌 DTO로 변환하는 방법**:
    *   DTO 대신 JPA TUPLE 조회
    *   DTO 대신 MAP 조회
    *   `@SqlResultSetMapping` (복잡)
    *   Hibernate Result Transformer (복잡)
    *   네이티브 SQL을 DTO로 조회할 때는 `JdbcTemplate` or `myBatis`를 권장합니다.

### Projections 활용
*   스프링 데이터 JPA 네이티브 쿼리 + 인터페이스 기반 Projections를 활용할 수 있습니다.
*   **예**: `@Query(value = "SELECT m.member_id as id, m.username, t.name as teamName FROM member m left join team t ON m.team_id = t.team_id", countQuery = "SELECT count(*) from member", nativeQuery = true)`

### 동적 네이티브 쿼리
*   하이버네이트를 직접 활용합니다.
*   스프링 `JdbcTemplate`, `myBatis`, `jooq`같은 외부 라이브러리를 사용합니다.
