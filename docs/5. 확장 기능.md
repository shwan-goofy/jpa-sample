# 5. 확장 기능

## 사용자 정의 리포지토리 구현
*   스프링 데이터 JPA 리포지토리는 인터페이스만 정의하고 구현체는 스프링이 자동 생성합니다.
*   스프링 데이터 JPA가 제공하는 인터페이스를 직접 구현하면 구현해야 하는 기능이 너무 많습니다.
*   다양한 이유로 인터페이스의 메서드를 직접 구현하고 싶다면 다음과 같은 방법을 사용할 수 있습니다.
    *   JPA 직접 사용 (EntityManager)
    *   스프링 JDBC Template 사용
    *   MyBatis 사용
    *   데이터베이스 커넥션 직접 사용 등
    *   Querydsl 사용
*   **사용자 정의 인터페이스 및 구현 클래스**:
    *   `MemberRepositoryCustom`과 같은 사용자 정의 인터페이스를 생성합니다.
    *   `MemberRepositoryImpl`과 같이 `리포지토리 인터페이스 이름 + Impl` 규칙으로 구현 클래스를 만듭니다.
    *   스프링 데이터 JPA가 이를 인식해서 스프링 빈으로 등록합니다.
    *   **Impl 대신 다른 이름으로 변경하고 싶으면**: `repository-impl-postfix` 설정을 변경할 수 있습니다 (XML 또는 JavaConfig).
*   **참고**: 실무에서는 주로 QueryDSL이나 SpringJdbcTemplate을 함께 사용할 때 사용자 정의 리포지토리 기능을 자주 사용합니다.
*   **사용자 정의 리포지토리 구현 최신 방식**:
    *   스프링 데이터 2.x부터는 사용자 정의 인터페이스 명 + `Impl` 방식도 지원합니다. (예: `MemberRepositoryCustomImpl`)
    *   기존 방식보다 이 방식이 사용자 정의 인터페이스 이름과 구현 클래스 이름이 비슷하므로 더 직관적이며, 여러 인터페이스를 분리해서 구현하는 것도 가능하기 때문에 새롭게 변경된 이 방식을 사용하는 것을 더 권장합니다.

## Auditing
*   엔티티를 생성, 변경할 때 변경한 사람과 시간을 추적하고 싶을 때 사용합니다.
*   **항목**: 등록일, 수정일, 등록자, 수정자

### 순수 JPA 사용
*   `@MappedSuperclass`와 `@Getter`를 사용하여 공통 엔티티 (`JpaBaseEntity`)를 만듭니다.
*   `@PrePersist`와 `@PreUpdate` 어노테이션을 사용하여 등록일(`createdDate`), 수정일(`updatedDate`)을 자동으로 설정합니다.

### 스프링 데이터 JPA 사용
*   **설정**:
    *   `@EnableJpaAuditing`: 스프링 부트 설정 클래스에 적용해야 합니다.
    *   `@EntityListeners(AuditingEntityListener.class)`: 엔티티에 적용하여 Auditing 기능을 활성화합니다.
*   **사용 어노테이션**:
    *   `@CreatedDate`
    *   `@LastModifiedDate`
    *   `@CreatedBy`
    *   `@LastModifiedBy`
*   **등록자, 수정자 처리**: `AuditorAware` 스프링 빈을 등록하여 현재 사용자 정보를 제공합니다. (`@Bean public AuditorAware<String> auditorProvider()`)
*   **주의**: `DataJpaApplication`에 `@EnableJpaAuditing`도 함께 등록해야 합니다.
*   **참고**:
    *   실무에서는 대부분의 엔티티는 등록시간, 수정시간이 필요하지만, 등록자, 수정자는 없을 수도 있습니다. 그래서 `BaseTimeEntity`와 `BaseEntity`와 같이 Base 타입을 분리하고, 원하는 타입을 선택해서 상속하는 것이 좋습니다.
    *   저장 시점에 등록일, 등록자는 물론이고, 수정일, 수정자도 같은 데이터가 저장됩니다. 데이터가 중복 저장되는 것 같지만, 이렇게 해두면 변경 컬럼만 확인해도 마지막에 업데이트한 유저를 확인할 수 있으므로 유지보수 관점에서 편리합니다.
    *   저장시점에 저장데이터만 입력하고 싶으면 `@EnableJpaAuditing(modifyOnCreate = false)` 옵션을 사용하면 됩니다.
*   **전체 적용**: `@EntityListeners(AuditingEntityListener.class)`를 생략하고 스프링 데이터 JPA가 제공하는 이벤트를 엔티티 전체에 적용하려면 `META-INF/orm.xml`에 설정하면 됩니다.

## Web 확장 - 도메인 클래스 컨버터
*   HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩해주는 기능입니다.
*   **사용 전**: `@PathVariable`로 `id`를 받아서 리포지토리에서 직접 엔티티를 조회해야 합니다.
*   **사용 후**: `@PathVariable("id") Member member`와 같이 직접 엔티티를 파라미터로 받을 수 있습니다. HTTP 요청은 회원 `id`를 받지만 도메인 클래스 컨버터가 중간에 동작해서 회원 엔티티 객체를 반환합니다.
*   도메인 클래스 컨버터도 리파지토리를 사용해서 엔티티를 찾습니다.
*   **주의**: 도메인 클래스 컨버터로 엔티티를 파라미터로 받으면, 이 엔티티는 단순 조회용으로만 사용해야 합니다. (트랜잭션이 없는 범위에서 엔티티를 조회했으므로, 엔티티를 변경해도 DB에 반영되지 않습니다.)

## Web 확장 - 페이징과 정렬
*   스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC에서 편리하게 사용할 수 있습니다.
*   **페이징과 정렬 예제**: 컨트롤러 메소드의 파라미터로 `Pageable` 객체를 받을 수 있습니다.
*   **요청 파라미터**: `page`, `size`, `sort`
    *   `page`: 현재 페이지, 0부터 시작합니다.
    *   `size`: 한 페이지에 노출할 데이터 건수
    *   `sort`: 정렬 조건을 정의합니다. (예: `sort=id,desc&sort=username,desc`)
*   **기본값 설정**:
    *   **글로벌 설정**: `spring.data.web.pageable.default-page-size` (기본 페이지 사이즈), `spring.data.web.pageable.max-page-size` (최대 페이지 사이즈)
    *   **개별 설정**: `@PageableDefault` 어노테이션을 사용하여 메소드 단위로 기본값을 설정할 수 있습니다.
*   **접두사**: 페이징 정보가 둘 이상이면 `@Qualifier`에 접두사명(`{접두사명}_xxx`)을 추가하여 구분할 수 있습니다.
*   **Page 내용을 DTO로 변환하기**:
    *   엔티티를 API로 직접 노출하면 다양한 문제가 발생하므로, 엔티티를 꼭 DTO로 변환해서 반환해야 합니다.
    *   `Page`는 `map()`을 지원해서 내부 데이터를 다른 DTO로 변환할 수 있습니다.
*   **Page를 1부터 시작하기**:
    *   스프링 데이터는 Page를 0부터 시작합니다.
    *   만약 1부터 시작하려면 `Pageable`, `Page`를 파라미터와 응답 값으로 사용하지 않고, 직접 클래스를 만들어서 처리하거나 `spring.data.web.pageable.one-indexed-parameters`를 `true`로 설정할 수 있습니다. 하지만 이 방법은 `web`에서 `page` 파라미터를 `-1` 처리할 뿐이므로, 응답값인 `Page`에 모두 0 페이지 인덱스를 사용하는 한계가 있습니다.
